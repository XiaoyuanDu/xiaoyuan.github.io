[{"title":"DjangoCustomCLI头脑风暴","path":"/2023/08/07/tech/Django/CustomCLI/DjangoCustomCLI头脑风暴/","content":"思考过程，Django源码解析 在这里我会详细记录我是如何思考去实现这一功能的，这篇文章也主要是帮助我理清实现思路。 功能定义我想要实现一个类似于 djangoadmin 的 startapp/startproject 的命令，来省去使用我开发的框架时需要定义的诸多文件，省去大量重复操作，使项目结构更一致。 使用方式或许如下：yourproject startapp yourappname 还会有一些选项来支持自定义生成文件中的内容。 寻找实现方案因为这是在个人框架中的自定义CLI，所以开源的轮子是不可能会有的。所以第一步我考虑的是，能否继承扩展Django的CLI，来实现这一功能。 继承DjangoCLI的方案如Django的官方文档 所述，可以通过继承 Django 提供的 BaseCommand 来添加自定义命令，大概的使用方法如下： 1234567891011from django.core.management.base import BaseCommand, CommandErrorclass Command(BaseCommand): help = &quot;Help Message&quot; def add_arguments(self, parser): parser.add_argument(...) # add your options def handle(self, *args, **options): # handle your command here pass 这个方法可以直接利用Django强大的CLI来扩展，但有两点要求： 项目中有settings.py，因为需要其中的INSTALLED_APPS 来注册命令 有 manage.py 文件来执行命令但我的项目是一个Django的框架，并不符合上述两点要求，所以这个方案不可行。 仿照Django的CLI，简单复写我们可以对Django的CLI做个简单的包装，处理自定义命令，Django的原生命令可以直接转发。 在项目目录下，创建目录如下结构： 12345├── management│ ├── __init__.py│ └── commands│ ├── __init__.py│ └── startyourprojectapp.py 并在setup.py 的 setuptools.setup 中添加以下配置： 123456789\tsetuptools.setup( ..., entry_points=&#123; &#x27;console_scripts&#x27;: [ &#x27;yourproject = yourproject.management:main&#x27;, ], &#125;,\t...) OK，在写代码之前，我们先来稍微深入了解下Django CLI是怎么工作的。 深入DjangoCLI整个CLI程序的入口就在下面这个函数： 12345# django.core.management.__init__.pydef execute_from_command_line(argv=None): &quot;&quot;&quot;Run a ManagementUtility.&quot;&quot;&quot; utility = ManagementUtility(argv) utility.execute() 这个函数中Django实例化了一个ManagementUtility, 把argv传给了它，然后执行execute 方法。我们继续深入ManagementUtility： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596class ManagementUtility: &quot;&quot;&quot; Encapsulate the logic of the django-admin and manage.py utilities. &quot;&quot;&quot; def __init__(self, argv=None): self.argv = argv or sys.argv[:] self.prog_name = os.path.basename(self.argv[0]) if self.prog_name == &quot;__main__.py&quot;: self.prog_name = &quot;python -m django&quot; self.settings_exception = None def execute(self): &quot;&quot;&quot; Given the command-line arguments, figure out which subcommand is being run, create a parser appropriate to that command, and run it. &quot;&quot;&quot; try: subcommand = self.argv[1] except IndexError: subcommand = &quot;help&quot; # Display help if no arguments were given. # Preprocess options to extract --settings and --pythonpath. # These options could affect the commands that are available, so they # must be processed early. parser = CommandParser( prog=self.prog_name, usage=&quot;%(prog)s subcommand [options] [args]&quot;, add_help=False, allow_abbrev=False, ) parser.add_argument(&quot;--settings&quot;) parser.add_argument(&quot;--pythonpath&quot;) parser.add_argument(&quot;args&quot;, nargs=&quot;*&quot;) # catch-all try: options, args = parser.parse_known_args(self.argv[2:]) handle_default_options(options) except CommandError: pass # Ignore any option errors at this point. try: settings.INSTALLED_APPS except ImproperlyConfigured as exc: self.settings_exception = exc except ImportError as exc: self.settings_exception = exc if settings.configured: # Start the auto-reloading dev server even if the code is broken. # The hardcoded condition is a code smell but we can&#x27;t rely on a # flag on the command class because we haven&#x27;t located it yet. if subcommand == &quot;runserver&quot; and &quot;--noreload&quot; not in self.argv: try: autoreload.check_errors(django.setup)() except Exception: # The exception will be raised later in the child process # started by the autoreloader. Pretend it didn&#x27;t happen by # loading an empty list of applications. apps.all_models = defaultdict(dict) apps.app_configs = &#123;&#125; apps.apps_ready = apps.models_ready = apps.ready = True # Remove options not compatible with the built-in runserver # (e.g. options for the contrib.staticfiles&#x27; runserver). # Changes here require manually testing as described in # #27522. _parser = self.fetch_command(&quot;runserver&quot;).create_parser( &quot;django&quot;, &quot;runserver&quot; ) _options, _args = _parser.parse_known_args(self.argv[2:]) for _arg in _args: self.argv.remove(_arg) # In all other cases, django.setup() is required to succeed. else: django.setup() self.autocomplete() if subcommand == &quot;help&quot;: if &quot;--commands&quot; in args: sys.stdout.write(self.main_help_text(commands_only=True) + &quot; &quot;) elif not options.args: sys.stdout.write(self.main_help_text() + &quot; &quot;) else: self.fetch_command(options.args[0]).print_help( self.prog_name, options.args[0] ) # Special-cases: We want &#x27;django-admin --version&#x27; and # &#x27;django-admin --help&#x27; to work, for backwards compatibility. elif subcommand == &quot;version&quot; or self.argv[1:] == [&quot;--version&quot;]: sys.stdout.write(django.get_version() + &quot; &quot;) elif self.argv[1:] in ([&quot;--help&quot;], [&quot;-h&quot;]): sys.stdout.write(self.main_help_text() + &quot; &quot;) else: self.fetch_command(subcommand).run_from_argv(self.argv) 可以看到，execute 的方法主要进行了以下几步： 获取到subcommand 创建CommandParser，并添加相关Parser 检查settings的INSTALLED_APPS 针对特殊命令的处理 调用fetch_commands 上面的第三步就是真正阻挡我们的地方（可惜Django没有把该步骤抽象出一个函数，不然可以直接绕过）了解了Django的CLI基本工作流程（不用过多深入），我们可以用一个类来持有一个Django 的ManagementUtility，拦截自定义Command，转发其余命令。 在这个文件中，还有一个我们后面会用到的一个函数 load_command_class: 12345678def load_command_class(app_name, name): &quot;&quot;&quot; Given a command name and an application name, return the Command class instance. Allow all errors raised by the import process (ImportError, AttributeError) to propagate. &quot;&quot;&quot; module = import_module(&quot;%s.management.commands.%s&quot; % (app_name, name)) return module.Command() 其作用就是从&#123;app_name&#125;.management.commands.&#123;name&#125; import 你的 自定义命令所在的module，然后返回该模组中的Commad类实例。 如何复用Django的startapp命令Django的startapp是一个十分成熟且强大的命令，我们可以先看一下它是怎么写的。 startapp/startproject 都是基于TemplateCommand的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125class TemplateCommand(BaseCommand): &quot;&quot;&quot; Copy either a Django application layout template or a Django project layout template into the specified directory. :param style: A color style object (see django.core.management.color). :param app_or_project: The string &#x27;app&#x27; or &#x27;project&#x27;. :param name: The name of the application or project. :param directory: The directory to which the template should be copied. :param options: The additional variables passed to project or app templates &quot;&quot;&quot; requires_system_checks = [] # The supported URL schemes url_schemes = [&quot;http&quot;, &quot;https&quot;, &quot;ftp&quot;] # Rewrite the following suffixes when determining the target filename. rewrite_template_suffixes = ( # Allow shipping invalid .py files without byte-compilation. (&quot;.py-tpl&quot;, &quot;.py&quot;), ) def handle(self, app_or_project, name, target=None, **options): self.app_or_project = app_or_project self.a_or_an = &quot;an&quot; if app_or_project == &quot;app&quot; else &quot;a&quot; self.paths_to_remove = [] self.verbosity = options[&quot;verbosity&quot;] ... extensions = tuple(handle_extensions(options[&quot;extensions&quot;])) extra_files = [] excluded_directories = [&quot;.git&quot;, &quot;__pycache__&quot;] for file in options[&quot;files&quot;]: extra_files.extend(map(lambda x: x.strip(), file.split(&quot;,&quot;))) if exclude := options.get(&quot;exclude&quot;): for directory in exclude: excluded_directories.append(directory.strip()) ... base_name = &quot;%s_name&quot; % app_or_project base_subdir = &quot;%s_template&quot; % app_or_project base_directory = &quot;%s_directory&quot; % app_or_project camel_case_name = &quot;camel_case_%s_name&quot; % app_or_project camel_case_value = &quot;&quot;.join(x for x in name.title() if x != &quot;_&quot;) context = Context( &#123; **options, base_name: name, base_directory: top_dir, camel_case_name: camel_case_value, &quot;docs_version&quot;: get_docs_version(), &quot;django_version&quot;: django.__version__, &#125;, autoescape=False, ) template_dir = self.handle_template(options[&quot;template&quot;], base_subdir) prefix_length = len(template_dir) + 1 for root, dirs, files in os.walk(template_dir): path_rest = root[prefix_length:] relative_dir = path_rest.replace(base_name, name) if relative_dir: target_dir = os.path.join(top_dir, relative_dir) os.makedirs(target_dir, exist_ok=True) for dirname in dirs[:]: if &quot;exclude&quot; not in options: if dirname.startswith(&quot;.&quot;) or dirname == &quot;__pycache__&quot;: dirs.remove(dirname) elif dirname in excluded_directories: dirs.remove(dirname) for filename in files: if filename.endswith((&quot;.pyo&quot;, &quot;.pyc&quot;, &quot;.py.class&quot;)): # Ignore some files as they cause various breakages. continue old_path = os.path.join(root, filename) new_path = os.path.join( top_dir, relative_dir, filename.replace(base_name, name) ) for old_suffix, new_suffix in self.rewrite_template_suffixes: if new_path.endswith(old_suffix): new_path = new_path[: -len(old_suffix)] + new_suffix break # Only rewrite once if os.path.exists(new_path): raise CommandError( &quot;%s already exists. Overlaying %s %s into an existing &quot; &quot;directory won&#x27;t replace conflicting files.&quot; % ( new_path, self.a_or_an, app_or_project, ) ) # Only render the Python files, as we don&#x27;t want to # accidentally render Django templates files if new_path.endswith(extensions) or filename in extra_files: with open(old_path, encoding=&quot;utf-8&quot;) as template_file: content = template_file.read() template = Engine().from_string(content) content = template.render(context) with open(new_path, &quot;w&quot;, encoding=&quot;utf-8&quot;) as new_file: new_file.write(content) else: shutil.copyfile(old_path, new_path) ... def handle_template(self, template, subdir): &quot;&quot;&quot; Determine where the app or project templates are. Use django.__path__[0] as the default because the Django install directory isn&#x27;t known. &quot;&quot;&quot; if template is None: return os.path.join(django.__path__[0], &quot;conf&quot;, subdir) else: ... # doing something when template is given raise CommandError( &quot;couldn&#x27;t handle %s template %s.&quot; % (self.app_or_project, template) ) 这段代码比较复杂，我做了一些删减，还涉及到了很多os库的函数, 列举一些其中不能顾名思义的函数： os.getcwd(): 获取当前目录的绝对路径 os.path.expanduser: 把~换成用户文件夹的绝对路径 os.path.normpath: 把path标准化 例：path &#x3D; “&#x2F;path&#x2F;to&#x2F;..&#x2F;another&#x2F;dir” -&gt; path &#x3D; os.path.normpath(path) -&gt; path &#x3D; “&#x2F;path&#x2F;another&#x2F;directory” 处理Template的具体步骤是： 确定需要render的Template 生成render需要的Context 用handle_template寻找到template的目录 渲染Template 聚焦到我们需要达成的功能，我们主要可以利用的是handle_template，通过将我们自己的Template路径通过**options[&#39;template&#39;] 传进去即可。 开始写代码接回上文我们在setup中添加好配置之后，在management.__init__.py 中添加我们对Django Management Utility的一个转发类并添加入口函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import osfrom django.core.management import ManagementUtility, load_command_classimport sysfrom django.core.management.base import ( CommandError, CommandParser,)class yourprojectManagementUtilityAdapter: def __init__(self, argv=None): self.argv = argv or sys.argv[:] self.prog_name = os.path.basename(self.argv[0]) if self.prog_name == &quot;__main__.py&quot;: self.prog_name = &quot;python -m django&quot; self._management_utility = ManagementUtility(argv) def execute(self): if not self._execute_extended_commands(): # if failed to execute extended command, forward it to Django CLI self._management_utility.execute() def _execute_extended_commands(self): try: subcommand = self.argv[1] except IndexError: return False # parse the command line args and options parser = CommandParser( prog=self.prog_name, usage=&quot;%(prog)s subcommand [options] [args]&quot;, add_help=False, allow_abbrev=False, ) try: options, args = parser.parse_known_args(self.argv[2:]) except CommandError: pass # Ignore any option errors at this point. try: self._fetch_command(subcommand).run_from_argv(self.argv) except: return False return True def _fetch_command(self, subcommand): return load_command_class(&#x27;yourproject&#x27;, subcommand)def main(): utility = yourprojectManagementUtilityAdapter(sys.argv) utility.execute() 在上述代码中，我对输入进来的命令行首先做了拦截，尝试用我自定义的命令去处理，如果这过程中有任何错误，我就会将该输入转发给Django的CLI。 1234567891011121314151617181920# management.commands.startyourprojectappimport osfrom django.core.management.templates import TemplateCommandimport yourprojectclass Command(TemplateCommand): help = ( &quot;Creates a yourproject Style Django app directory structure for the given app name in &quot; &quot;the current directory or optionally in the given directory.&quot;) def handle(self, **options): app_name = options.pop(&quot;name&quot;) target = options.pop(&quot;directory&quot;) template_dir = os.path.join(yourproject.__path__[0], &quot;app_template&quot;) super().handle(&#x27;app&#x27;, app_name, target, **&#123; **options, &quot;template&quot;: template_dir &#125;) 然后在commands文件夹中添加一个自定义命令，如上。注意，类名必须是Command, 因为我们使用的是Django 的 load_command_class，默认只加载module中的Command类。 到此一个自定义的，且不需要settings.py 和 manage.py 的 命令行程序就大功告成了，可以运行一下命令试试: yourproject startyourprojectapp xxxx","tags":["Backend","Python","头脑风暴"],"categories":["Django"]},{"title":"Django自定义CLI开发","path":"/2023/08/07/tech/Django/CustomCLI/Django自定义CLI开发/","content":"开发一个Django第三方框架的CLI 背景在一开始使用Django的时候，便被它极其便捷的CLI工具 djangoadmin 吸引了，一行命令即可直接创建一个Django项目所需的所有基本文件：djangoadmin startproject yourproject &amp; cd yourproject &amp; djangoadmin startapp yourapp现在自己开发了一个Django的第三方框架之后，由于使用该框架的项目也需要有一定的结构性，而用像djangoadmin这样的CLI创建的项目的结构也会十分一致，所以就萌生了自己扩展Django的CLI的想法。 说明这篇文章是经过整理之后的类似教程的东西，与之相对应的，我会在 DjangoCustomCLI头脑风暴中详细记录自己的思考过程，有兴趣的话可以自行阅读。 思路寻常的第三方Django应用可以直接通过添加一个继承了BaseCommand的类来实现拓展命令，但这个方式需要： 项目中有settings.py，因为需要其中的INSTALLED_APPS 来注册命令 有 manage.py 文件来执行命令然而本项目是一个Django框架，并不符合上述要求。 经过对Django CLI代码的一些深入探索，发现可以去曲线救国，通过用一个对Django CLI的Adapterl来先处理我们自定义的命令，而后再转发Django命令。这个方式可以绕过使用我们自定义命令时，Django会做的检查，达到我们的目的。 实现在项目目录下，创建目录如下结构： 12345├── management│ ├── __init__.py│ └── commands│ ├── __init__.py│ └── startyourprojectapp.py 并在setup.py 的 setuptools.setup 中添加以下配置： 123456789\tsetuptools.setup( ..., entry_points=&#123; &#x27;console_scripts&#x27;: [ &#x27;yourproject = yourproject.management:main&#x27;, ], &#125;,\t...) 然后在management.__init__.py 中添加我们对Django Management Utility的一个转发类并添加入口函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import osfrom django.core.management import ManagementUtility, load_command_classimport sysfrom django.core.management.base import ( CommandError, CommandParser,)class yourprojectManagementUtilityAdapter: def __init__(self, argv=None): self.argv = argv or sys.argv[:] self.prog_name = os.path.basename(self.argv[0]) if self.prog_name == &quot;__main__.py&quot;: self.prog_name = &quot;python -m django&quot; self._management_utility = ManagementUtility(argv) def execute(self): if not self._execute_extended_commands(): # if failed to execute extended command, forward it to Django CLI self._management_utility.execute() def _execute_extended_commands(self): try: subcommand = self.argv[1] except IndexError: return False # parse the command line args and options parser = CommandParser( prog=self.prog_name, usage=&quot;%(prog)s subcommand [options] [args]&quot;, add_help=False, allow_abbrev=False, ) try: options, args = parser.parse_known_args(self.argv[2:]) except CommandError: pass # Ignore any option errors at this point. try: self._fetch_command(subcommand).run_from_argv(self.argv) except: return False return True def _fetch_command(self, subcommand): return load_command_class(&#x27;yourproject&#x27;, subcommand)def main(): utility = yourprojectManagementUtilityAdapter(sys.argv) utility.execute() 在上述代码中，我对输入进来的命令行首先做了拦截，尝试用我自定义的命令去处理，如果这过程中有任何错误，我就会将该输入转发给Django的CLI。 1234567891011121314151617181920# management.commands.startyourprojectappimport osfrom django.core.management.templates import TemplateCommandimport yourprojectclass Command(TemplateCommand): help = ( &quot;Creates a yourproject Style Django app directory structure for the given app name in &quot; &quot;the current directory or optionally in the given directory.&quot;) def handle(self, **options): app_name = options.pop(&quot;name&quot;) target = options.pop(&quot;directory&quot;) template_dir = os.path.join(yourproject.__path__[0], &quot;app_template&quot;) super().handle(&#x27;app&#x27;, app_name, target, **&#123; **options, &quot;template&quot;: template_dir &#125;) 然后在commands文件夹中添加一个自定义命令，如上。注意，类名必须是Command, 因为我们使用的是Django 的 load_command_class，默认只加载module中的Command类。 到此一个自定义的，且不需要settings.py 和 manage.py 的 命令行程序就大功告成了，可以运行一下命令试试: yourproject startyourprojectapp xxxx","tags":["Backend","Python","CLI"],"categories":["Django"]},{"title":"关于我","path":"/2023/08/06/others/关于我/","content":"学习，永远在路上 自我介绍 00后，在上海长大，热爱运动 23年6月于上海科技大学本科毕业 23年7月在Orka就业，担任后端工程师一职 喜欢于生活中思考代码 Code lives in your life To be continued… 研究方向 系统架构 高并发 领域驱动设计","tags":["about-me"],"categories":["others"]},{"title":"2023年阅读书单","path":"/2023/08/06/reading/2023年阅读书单/","content":"大量的阅读，大量的思考，大量的输出 自我提升 大胆投资自己 极简生活指南 纳瓦尔宝典 钝感力 事实 30天说话训练 传记 坏血","tags":["reading","book-list","2023"],"categories":["reading"]}]