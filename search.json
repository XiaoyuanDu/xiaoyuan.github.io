[{"title":"DjangoCustomCLI头脑风暴","path":"/2023/08/07/tech/Django/CustomCLI/DjangoCustomCLI头脑风暴/","content":"在这里我会详细记录我是如何思考去实现这一功能的，这篇文章也主要是帮助我理清实现思路。 功能定义我想要实现一个类似于 djangoadmin 的 startapp/startproject 的命令，来省去使用我开发的框架时需要定义的诸多文件，省去大量重复操作，使项目结构更一致。 使用方式或许如下：dddd startapp yourappname 还会有一些选项来支持自定义生成文件中的内容。 寻找实现方案因为这是在个人框架中的自定义CLI，所以开源的轮子是不可能会有的。所以第一步我考虑的是，能否继承扩展Django的CLI，来实现这一功能。 继承DjangoCLI的方案如Django的官方文档 所述，可以通过继承 Django 提供的 BaseCommand 来添加自定义命令，大概的使用方法如下： 1234567891011from django.core.management.base import BaseCommand, CommandErrorclass Command(BaseCommand): help = &quot;Help Message&quot; def add_arguments(self, parser): parser.add_argument(...) # add your options def handle(self, *args, **options): # handle your command here pass 这个方法可以直接利用Django强大的CLI来扩展，但有两点要求： 项目中有settings.py，因为需要其中的INSTALLED_APPS 来注册命令 有 manage.py 文件来执行命令但我的项目是一个Django的框架，并不符合上述两点要求，所以这个方案不可行。 仿照Django的CLI，简单复写我们可以对Django的CLI做个简单的包装，处理自定义命令，Django的原生命令可以直接转发。 在项目目录下，创建目录如下结构： 12345├── management│ ├── __init__.py│ └── commands│ ├── __init__.py│ └── startddddapp.py 并在setup.py 的 setuptools.setup 中添加以下配置： 123456789\tsetuptools.setup( ..., entry_points=&#123; &#x27;console_scripts&#x27;: [ &#x27;dddd = dddd.management:main&#x27;, ], &#125;,\t...) OK，在写代码之前，我们先来稍微深入了解下Django CLI是怎么工作的。 深入DjangoCLI整个CLI程序的入口就在下面这个函数： 12345# django.core.management.__init__.pydef execute_from_command_line(argv=None): &quot;&quot;&quot;Run a ManagementUtility.&quot;&quot;&quot; utility = ManagementUtility(argv) utility.execute() 这个函数中Django实例化了一个ManagementUtility, 把argv传给了它，然后执行execute 方法。我们继续深入ManagementUtility： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240class ManagementUtility: &quot;&quot;&quot; Encapsulate the logic of the django-admin and manage.py utilities. &quot;&quot;&quot; def __init__(self, argv=None): self.argv = argv or sys.argv[:] self.prog_name = os.path.basename(self.argv[0]) if self.prog_name == &quot;__main__.py&quot;: self.prog_name = &quot;python -m django&quot; self.settings_exception = None def main_help_text(self, commands_only=False): &quot;&quot;&quot;Return the script&#x27;s main help text, as a string.&quot;&quot;&quot; if commands_only: usage = sorted(get_commands()) else: usage = [ &quot;&quot;, &quot;Type &#x27;%s help &lt;subcommand&gt;&#x27; for help on a specific subcommand.&quot; % self.prog_name, &quot;&quot;, &quot;Available subcommands:&quot;, ] commands_dict = defaultdict(lambda: []) for name, app in get_commands().items(): if app == &quot;django.core&quot;: app = &quot;django&quot; else: app = app.rpartition(&quot;.&quot;)[-1] commands_dict[app].append(name) style = color_style() for app in sorted(commands_dict): usage.append(&quot;&quot;) usage.append(style.NOTICE(&quot;[%s]&quot; % app)) for name in sorted(commands_dict[app]): usage.append(&quot; %s&quot; % name) # Output an extra note if settings are not properly configured if self.settings_exception is not None: usage.append( style.NOTICE( &quot;Note that only Django core commands are listed &quot; &quot;as settings are not properly configured (error: %s).&quot; % self.settings_exception ) ) return &quot; &quot;.join(usage) def fetch_command(self, subcommand): &quot;&quot;&quot; Try to fetch the given subcommand, printing a message with the appropriate command called from the command line (usually &quot;django-admin&quot; or &quot;manage.py&quot;) if it can&#x27;t be found. &quot;&quot;&quot; # Get commands outside of try block to prevent swallowing exceptions commands = get_commands() try: app_name = commands[subcommand] except KeyError: if os.environ.get(&quot;DJANGO_SETTINGS_MODULE&quot;): # If `subcommand` is missing due to misconfigured settings, the # following line will retrigger an ImproperlyConfigured exception # (get_commands() swallows the original one) so the user is # informed about it. settings.INSTALLED_APPS elif not settings.configured: sys.stderr.write(&quot;No Django settings specified. &quot;) possible_matches = get_close_matches(subcommand, commands) sys.stderr.write(&quot;Unknown command: %r&quot; % subcommand) if possible_matches: sys.stderr.write(&quot;. Did you mean %s?&quot; % possible_matches[0]) sys.stderr.write(&quot; Type &#x27;%s help&#x27; for usage. &quot; % self.prog_name) sys.exit(1) if isinstance(app_name, BaseCommand): # If the command is already loaded, use it directly. klass = app_name else: klass = load_command_class(app_name, subcommand) return klass def autocomplete(self): &quot;&quot;&quot; Output completion suggestions for BASH. The output of this function is passed to BASH&#x27;s `COMREPLY` variable and treated as completion suggestions. `COMREPLY` expects a space separated string as the result. The `COMP_WORDS` and `COMP_CWORD` BASH environment variables are used to get information about the cli input. Please refer to the BASH man-page for more information about this variables. Subcommand options are saved as pairs. A pair consists of the long option string (e.g. &#x27;--exclude&#x27;) and a boolean value indicating if the option requires arguments. When printing to stdout, an equal sign is appended to options which require arguments. Note: If debugging this function, it is recommended to write the debug output in a separate file. Otherwise the debug output will be treated and formatted as potential completion suggestions. &quot;&quot;&quot; # Don&#x27;t complete if user hasn&#x27;t sourced bash_completion file. if &quot;DJANGO_AUTO_COMPLETE&quot; not in os.environ: return cwords = os.environ[&quot;COMP_WORDS&quot;].split()[1:] cword = int(os.environ[&quot;COMP_CWORD&quot;]) try: curr = cwords[cword - 1] except IndexError: curr = &quot;&quot; subcommands = [*get_commands(), &quot;help&quot;] options = [(&quot;--help&quot;, False)] # subcommand if cword == 1: print(&quot; &quot;.join(sorted(filter(lambda x: x.startswith(curr), subcommands)))) # subcommand options # special case: the &#x27;help&#x27; subcommand has no options elif cwords[0] in subcommands and cwords[0] != &quot;help&quot;: subcommand_cls = self.fetch_command(cwords[0]) # special case: add the names of installed apps to options if cwords[0] in (&quot;dumpdata&quot;, &quot;sqlmigrate&quot;, &quot;sqlsequencereset&quot;, &quot;test&quot;): try: app_configs = apps.get_app_configs() # Get the last part of the dotted path as the app name. options.extend((app_config.label, 0) for app_config in app_configs) except ImportError: # Fail silently if DJANGO_SETTINGS_MODULE isn&#x27;t set. The # user will find out once they execute the command. pass parser = subcommand_cls.create_parser(&quot;&quot;, cwords[0]) options.extend( (min(s_opt.option_strings), s_opt.nargs != 0) for s_opt in parser._actions if s_opt.option_strings ) # filter out previously specified options from available options prev_opts = &#123;x.split(&quot;=&quot;)[0] for x in cwords[1 : cword - 1]&#125; options = (opt for opt in options if opt[0] not in prev_opts) # filter options by current input options = sorted((k, v) for k, v in options if k.startswith(curr)) for opt_label, require_arg in options: # append &#x27;=&#x27; to options which require args if require_arg: opt_label += &quot;=&quot; print(opt_label) # Exit code of the bash completion function is never passed back to # the user, so it&#x27;s safe to always exit with 0. # For more details see #25420. sys.exit(0) def execute(self): &quot;&quot;&quot; Given the command-line arguments, figure out which subcommand is being run, create a parser appropriate to that command, and run it. &quot;&quot;&quot; try: subcommand = self.argv[1] except IndexError: subcommand = &quot;help&quot; # Display help if no arguments were given. # Preprocess options to extract --settings and --pythonpath. # These options could affect the commands that are available, so they # must be processed early. parser = CommandParser( prog=self.prog_name, usage=&quot;%(prog)s subcommand [options] [args]&quot;, add_help=False, allow_abbrev=False, ) parser.add_argument(&quot;--settings&quot;) parser.add_argument(&quot;--pythonpath&quot;) parser.add_argument(&quot;args&quot;, nargs=&quot;*&quot;) # catch-all try: options, args = parser.parse_known_args(self.argv[2:]) handle_default_options(options) except CommandError: pass # Ignore any option errors at this point. try: settings.INSTALLED_APPS except ImproperlyConfigured as exc: self.settings_exception = exc except ImportError as exc: self.settings_exception = exc if settings.configured: # Start the auto-reloading dev server even if the code is broken. # The hardcoded condition is a code smell but we can&#x27;t rely on a # flag on the command class because we haven&#x27;t located it yet. if subcommand == &quot;runserver&quot; and &quot;--noreload&quot; not in self.argv: try: autoreload.check_errors(django.setup)() except Exception: # The exception will be raised later in the child process # started by the autoreloader. Pretend it didn&#x27;t happen by # loading an empty list of applications. apps.all_models = defaultdict(dict) apps.app_configs = &#123;&#125; apps.apps_ready = apps.models_ready = apps.ready = True # Remove options not compatible with the built-in runserver # (e.g. options for the contrib.staticfiles&#x27; runserver). # Changes here require manually testing as described in # #27522. _parser = self.fetch_command(&quot;runserver&quot;).create_parser( &quot;django&quot;, &quot;runserver&quot; ) _options, _args = _parser.parse_known_args(self.argv[2:]) for _arg in _args: self.argv.remove(_arg) # In all other cases, django.setup() is required to succeed. else: django.setup() self.autocomplete() if subcommand == &quot;help&quot;: if &quot;--commands&quot; in args: sys.stdout.write(self.main_help_text(commands_only=True) + &quot; &quot;) elif not options.args: sys.stdout.write(self.main_help_text() + &quot; &quot;) else: self.fetch_command(options.args[0]).print_help( self.prog_name, options.args[0] ) # Special-cases: We want &#x27;django-admin --version&#x27; and # &#x27;django-admin --help&#x27; to work, for backwards compatibility. elif subcommand == &quot;version&quot; or self.argv[1:] == [&quot;--version&quot;]: sys.stdout.write(django.get_version() + &quot; &quot;) elif self.argv[1:] in ([&quot;--help&quot;], [&quot;-h&quot;]): sys.stdout.write(self.main_help_text() + &quot; &quot;) else: self.fetch_command(subcommand).run_from_argv(self.argv)","tags":["Python","Backend","头脑风暴"],"categories":["Django"]},{"title":"Django自定义CLI开发","path":"/2023/08/07/tech/Django/CustomCLI/Django自定义CLI开发/","content":"背景在一开始使用Django的时候，便被它极其便捷的CLI工具 djangoadmin 吸引了，一行命令即可直接创建一个Django项目所需的所有基本文件：djangoadmin startproject yourproject &amp; cd yourproject &amp; djangoadmin startapp yourapp 现在自己开发了一个Django的第三方框架之后，由于使用该框架的项目也需要有一定的结构性，而用像djangoadmin这样的CLI创建的项目的结构也会十分一致，所以就萌生了自己扩展Django的CLI的想法。 说明这篇文章是经过整理之后的类似教程的东西，与之相对应的，我会在 [[DjangoCustomCLI头脑风暴]] 中详细记录自己的思考过程，有兴趣的话可以自行阅读。","tags":["Python","Backend","CLI"],"categories":["Django"]},{"title":"关于我","path":"/2023/08/06/others/关于我/","content":"学习，永远在路上 自我介绍 00后，在上海长大，热爱运动 23年6月于上海科技大学本科毕业 23年7月在Orka就业，担任后端工程师一职 喜欢于生活中思考代码 Code lives in your life To be continued… 研究方向 系统架构 高并发 领域驱动设计","tags":["about-me"],"categories":["others"]},{"title":"2023年阅读书单","path":"/2023/08/06/reading/2023年阅读书单/","content":"大量的阅读，大量的思考，大量的输出 自我提升 大胆投资自己 极简生活指南 纳瓦尔宝典 钝感力 事实 30天说话训练 传记 坏血","tags":["reading","book-list","2023"],"categories":["reading"]}]